---
title: 编码与实现
createTime: 2025/11/24 14:34:50
permalink: /qa/basic/javascript/spnc724u/
outline: 2
---

## 变量提升与优先级

下面的代码执行结果是什么？

<ClientOnly>
  <JSRunner :code="code1" :height="400" />
</ClientOnly>

这段代码考察变量提升与优先级：函数声明会被提升到作用域顶部，`var` 也会被提升，但函数优先级更高，不会覆盖已经存在的同名函数声明。所以上面的代码在执行上下文阶段等效以下代码：

```js
function foo() {
  console.log(1);
}
// var foo; ← 被忽略，因为 foo 已由函数声明定义

// 调用函数
foo();
```

`foo` 调用时指向的是函数声明。

## 函数实例

下面的代码执行结果是什么？

<ClientOnly>
  <JSRunner :code="code2" />
</ClientOnly>

<!-- let code2 = `const obj = {
  fn1: () => console.log(this),
  fn2: function() {console.log(this)}
}
obj.fn1();
obj.fn2();
const x = new obj.fn1();
const y = new obj.fn2();
` -->

obj 包含两个方法属性，其中 fn1 是箭头函数，fn2 是普通函数。随后分别执行和实例化则两个函数。

对于箭头函数而言，没有自己的 this ，只能捕获上下文中的 this 值，所以 fn1 中的 this 指向 window（严格模式下为 undefined）。
fn2 是一个普通函数，this 在运行时根据调用方式动态绑定，因此 fn2 的 this 为 obj 对象。

随后的函数实例，因为箭头函数 fn1 没有自己的 this 与 prototype，不能被当作构造函数使用，因此 `new obj.fn1()` 报错。由于上面的 js 语句报错，
`const y = new obj.fn2();` 不会执行。若若注释上一行，因为普通函数能够作为构造函数使用，因此 this 指向创建的实例对象。

## typeof 的返回

下面的代码执行结果是什么？

<JSRunner :code="code3" height="300" />

在 `JavaScript` 中，null 是一种 原始值，表示有意缺少任何对象值（空对象值），因此 `typeof null` 为 `"object"`。
而 `typeof` 返回一个字符串，表示操作数的类型。因此 `typeof typeof null` 返回 `"string"`。

`console.log()` 是一个函数输出 1 ，而没有返回值，因此 `typeof console.log()` 返回 `"undefined"`。

<script setup>
let code1 = `foo()
var foo
function foo(){
  console.log(1)
}
`

let code2 = `const obj = {
  fn1: () => console.log(this),
  fn2: function() {console.log(this)}
}
obj.fn1();
obj.fn2();
const x = new obj.fn1();
const y = new obj.fn2();
`

const code3 = `console.log(typeof typeof null)
console.log(typeof console.log(1))`
</script>
