---
title: 设计与实现
createTime: 2025/11/17 17:37:49
permalink: /web/vue/principle/
---

## 响应系统

响应系统是 Vue.js 的核心，是响应式数据的关键。

### 基本实现

一般的 JS 对象数据并不会追踪更新，当它被改变时，那些依赖它的副作用函数并不知道它变了。

``` js
const obj = {
    name: '张三',
    age: 18
}

function changeAge() {
    document.body.innerHTML = obj.age
}

changeAge()

setTimeout(() => {
    obj.age = 19 // 1 秒后 age 改变，但视图不会更新
},1000)

```

上面的例子中，虽然 `obj.age` 被改变了，但函数 `changeAge` 并不知道它被改变了，因此它也不会被执行，视图就不会更新。所以，如果我们
能够拦截一个对象的读取和更改，就能够追踪到数据变化。

[Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 是 ES6 新增的 API，它可以拦截对目标对象的操。例如对象被访问了、被更改了，并可以自定义这些行为。所以我们可以创建一个 Proxy 来拦截对对象属性的访问和修改，来实现响应式数据。

1. 创建一个 Proxy 对象

创建一个基本对象，并使用 Proxy 进行代理，自定义 `get` 与 `set` 行为。

``` js
const obj = {
    name: '张三',
    age: 18
}

const proxyData = new Proxy(obj, {
    get(target, key) {
        return target[key]
    },
    set(target, key, value) {
        target[key] = value
        return true
    }
})
```

2. 添加副作用函数

当数据变化时，还需要在 `set` 中添加副作用函数。这样，当数据被修改时才会执行副作用函数。

我们可以使用 `Set` 来保存副作用函数，在 `get` 中使用 `add` 方法添加，在 `set` 中使用 `forEach` 方法遍历执行。

:::: demo expanded
::: code-tabs
@tab javascript
``` js
// 原始数据
const obj = {
    name: 'Tom',
    age: 18
}

// 副作用函数
function effect() {
  document.body.innerText = proxyData.name // [!code highlight]
}

// 使用 Set 保存副作用函数
const effectFn = new Set()

// 代理对象
const proxyData = new Proxy(obj, {
    get(target, key) {
        // 添加副作用函数
        effectFn.add(effect) // [!code ++]
        return target[key]
    },
    set(target, key, value) {
        target[key] = value
        // 遍历副作用函数并执行
        effectFn.forEach(fn => fn()) // [!code ++]
        return true
    }
})

// 执行副作用函数，触发读取
effect()
// 1 秒后修改响应式数据
setTimeout(() => {
  proxyData.name = 'Bob'
}, 1000)
```
:::
::::

在上面的代码中，使用 `Set` 保存副作用函数，实现当更改代理对象时，视图也会更新。（若你没有看到界面更新，请刷新页面）

在 Vue3 中，便是使用 `Proxy` 实现响应式数据，是响应系统的核心。上面的例子实现了一个最基本的响应系统，但完整的响应系统还有更多细节，
比如还需要注册副作用函数（上面的例子讲副作用函数写死了）、依赖收集等。

### 完善响应系统

上面的例子中，我们直接将副作用函数 `effect` 在 `get` 中添加，这样显然是不行的。因为，副作用函数不一定叫 `effect`，而且它还可能是一个匿名函数或者箭头函数。
另外一个对象可能有很多个字段，而每个字段又可能有很多个副作用函数，当我们需要更改某一个字段的数据时，`Proxy` 中根本不知道该字段对应的哪些副作用函数需要执行，
我们也不可能将所有副作用函数都添加到 `Proxy` 中。因此我们需要提供一个用来注册副作用函数的机制，并且还要改变字段与副作用函数关系的数据结构。

#### 注册副作用函数

在 Vue3 中，定义了一个 `effect` 函数，用来注册副作用函数。它接受一个参数，即副作用函数，并将它赋值给一个全局变量 `activeEffect`，存储当前活跃的副作用函数。同时执行副作用函数。

``` js
// 用一个全局变量存储被注册的副作用函数
let activeEffect
// effect 函数用于注册副作用函数
function effect(fn) {
  // 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给 activeEffect
  activeEffect = fn
  // 执行副作用函数
  fn()
}
```

需要再次执行副作用函数时，只需要调用 `effect` 函数即可。

```js
effect(() => {
    proxyData.name = 'Bob'
})
```

#### 依赖收集

依赖收集是实现响应系统较难的一环节。在上面的例子中，我们没有在副作用函数与被操作的目标字段之间建立任何联系，这就会导致我们更改了某一个字段，其它字段的副作用函数可能会被执行。
如果我们将 `key` 与 `effect` 关联起来，那么当 `key` 被修改时，与它关联的 `effect` 函数就会执行，依赖就会被正确收集。

一个目标对象 `target` 中有多个字段 `key`，每个字段都有多个副作用函数 `effect`，那么 `key` 与 `effect` 之间的关系可以表示为 `Map`。

<script>
const sampleCode = `const a = 1
const b = 2
console.log(a + b)

setTimeout(() => {
  console.log(a + b)
}, 1000)

`
</script>

<ClientOnly>
<JSRunner :code='sampleCode'></JSRunner>
</ClientOnly>
