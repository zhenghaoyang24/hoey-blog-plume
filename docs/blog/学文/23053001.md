---
title: JS中常用的数组处理函数
createTime: 2023/5/30
tags:
  - JavaScript
permalink: /blog/23053001/
---

JS对数组处理提供了许多方法，对目前在开发中经常用到且强大的方法做一个学习总结。

<!-- more -->

## 1.splice()

**功能**：splice() 方法用于添加或删除数组中的元素，**这种方法会改变原始数组**，返回被删除的元素。

**参数**：  
**splice(index,howmany,item1,..., itemX)**  
**index**：添加/删除的元素下标，使用负数可从数组结尾处规定位置。必须。  
**howmany**：要删除的元素个数，为0则不删除元素。必须。  
**item**：向数组中添加的元素，可以为多个。非必须。

<JSRunner :code="code1" />

## 2.sort

**功能**：可以对数组元素进行排序，默认排序顺序是根据字符串Unicode码点。  
**语法**：`arr.sort(compareFunction)` 。

1. 不指明compareFunction，那么元素会按照转换为的字符串的Unicode位点进行排序。
2. 指明compareFunction，数组将按照compareFunction返回值排序。  
   compareFunction(a, b)小于0，则a排在b前面。  
   compareFunction(a, b)大于0，则a排在b后面。  
   等于0，a b顺序不变，

<JSRunner :code="code2" />

## 3.foreach map filter every some

`foreach`,
`map`,
`filter`,
`every`,
`some`
具有相同点：不主动改变原数组，它们都遍历数组每一项，且每次循环时执行传入的回调函数。回调函数为：

```js
function (item,index,array){}
/**
 * item:循环的当前元素
 * index:当前元素下标
 * array:原数组
 * **/
```

### 1.foreach map

`foreach`每次循环执行回调函数，且没有返回值，类似 for 循环。`map`
会根据回调函数返回的处理结果，生成一个新数组。

<JSRunner :code="code3" />

### 2.filter

`filter`过滤元素，会将满足回调函数条件的元素筛选出来组成为一个新数组。

<JSRunner :code="code4" />

### 3.every some

`every`与`some`有相同之处，它们均根据回调函数判断遍历元素是否符合条件，区别在于
`every` **当所有元素满足条件才返回true，否则返回false；而`some`则是存在元素满足条件则返回true，否则返回false。**

<JSRunner :code="code5" />

## 4.reduce

`reduce()` 方法对数组中的每个元素按序执行一个提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。
`reduce()` 函数本身不改变原数组，除非函数内部有对原数组的修改。

**语法**：reduce(callbackFn, initialValue)  
**参数** ：

1. **callbackFn**：为数组中每个元素执行的函数。其返回值将作为下一次调用 callbackFn 时的 accumulator 参数。对于最后一次调用，返回值将作为 reduce() 的返回值。该函数被调用时将传入以下参数：
   1. **accumulator**：上一次调用 callbackFn 的结果。在第一次调用时，如果指定了 initialValue 则为指定的值，否则为 array[0] 的值。
   2. **currentValue**：当前元素的值。在第一次调用时，如果指定了 initialValue，则为 array[0]的值，否则为array[1]。
   3. **currentIndex**：currentValue 在数组中的索引位置。在第一次调用时，如果指定了 initialValue 则为 0，否则为 1。
   4. **array**：原数组。

2. **initialValue(可选)**：用于指定第一次accumulator的值，是否指定则会影响currentValue，currentIndex的值，如上。

**用法**：

<JSRunner :code="code6" />

js中还有更多数组处理的函数，学习可查看[此链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/at)。

<script setup>
const code1 = `var arr = [1, 2, 3, 4, 5];
var del = arr.splice(1, 2, 6, 7);
console.log(arr);
console.log(del);`

const code2 = `var a = [4, 2, 6, 1, 5, 9];

//升序  a-b<=0，则a在前，否则b在前
a.sort((a,b)=> a-b);
console.log(a);

//降序  b-a<=0，则a在前
a.sort((a,b)=> b-a);
console.log(a);

`

const code3 = `// 数组和 - 使用 forEach
let sum1 = 0;
let arr1 = [1, 2, 3, 4, 5];
const back = arr1.forEach((item) => {
  sum1 += item;
});
console.log('forEach 求和：' + sum1);
// forEach 总是返回 undefined
console.log('forEach 返回值：' + back);  


// 数组元素加1 - 使用 map
let arr2 = [1, 2, 3, 4, 5];
const res = arr2.map(item => item + 1);
console.log("新数组", res);
`

const code4 = `// 判断偶数
var list = [1, 2, 3, 4, 5];
var res = list.filter(function (item) {
  return item % 2 === 0;
});
console.log(res);`

const code5 = `let list = [1, 2, 3, 4, 5];
// 判断是否每个元素为偶数
let res_every = list.every(function (item) {
  return item % 2 === 0;
});
// 判断是否存在元素为偶数
let res_some = list.some(function (item) {
  return item % 2 === 0;
});
console.log(res_every);
console.log(res_some);`

const code6 = `let arr = [4, 3, 1, 6, 8];
const res1 = arr.reduce(function (accumulator, currentValue) {
  //由于没有指定initialValue,则第一次调用回调accumulator=4，currentValue=3
  return Math.max(accumulator, currentValue);
});
console.log(res1);
// 指定initialValue为9，因此第一次回调时，accumulator=9，currentValue=4
const res2 = arr.reduce(function (accumulator, currentValue) {
  return Math.max(accumulator, currentValue);
}, 9);
console.log(res2);`
</script>
