import{_ as i,c as a,d as n,o as e}from"./app-Ii0IARd7.js";const t={};function l(p,s){return e(),a("div",null,[...s[0]||(s[0]=[n(`<h2 id="保持组件纯粹" tabindex="-1"><a class="header-anchor" href="#保持组件纯粹"><span>保持组件纯粹</span></a></h2><blockquote><p>部分 JavaScript 函数是 <strong>纯粹</strong> 的，这类函数通常被称为纯函数。纯函数仅执行计算操作，不做其他操作。你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。</p></blockquote><p>在 React 中，<strong>保持组件纯粹</strong> 是一个核心理念，源自函数式编程思想。它强调 <strong>React 组件应当像纯函数一样工作</strong>。</p><p>而一个纯函数具有以下特点：</p><ul><li><ol><li>相同的输入，总是返回相同的输出。给定相同的参数，结果永远一致。</li></ol></li><li><ol start="2"><li>只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。</li></ol></li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-js"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 纯函数</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> add</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> a</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 非纯函数 （依赖外部变量 + 修改外部状态）</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">let</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> addAndLog</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">a</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  count</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">++</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 副作用：修改外部变量</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  console</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">log</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> a</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> b</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> +</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> count</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，我们每一次调用 <code>addAndLog(1,2)</code> 函数， <code>count</code> 的值都会不一样。这就不符合相同输入总是返回相同输出的纯函数特点，因此 <code>addAndLog()</code> 函数是不纯的。</p><p><code>React</code> 组件本质上是一个函数（函数组件）或 <code>render()</code> 方法（类组件）。为了确保可预测性、可测试性和高效渲染，组件在渲染过程中应保持纯粹， 而不改变在渲染前，就已存在的任何对象或变量。</p><p>在 React 中，副作用通常属于 事件处理程序。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。 <strong>即使事件处理程序是在你的组件内部定义的，它们也不会在渲染期间运行！</strong> <mark>因此事件处理程序无需是纯函数。</mark></p><div class="hint-container tip"><p class="hint-container-title">为什么“纯粹性”很重要？</p><ul><li><ol><li>可预测性：相同 props → 相同 UI，便于调试。</li></ol></li><li><ol start="2"><li>React 的并发渲染（Concurrent Rendering）依赖纯粹性 React 可能会多次调用组件函数（如预渲染、中断恢复），如果组件有副作用，会导致意外行为。</li></ol></li><li><ol start="3"><li>Strict Mode 能帮你发现问题 在开发模式下，Strict Mode 会故意双重调用渲染函数，暴露非纯组件的问题。</li></ol></li><li><ol start="4"><li>便于测试：纯组件无需 mock 全局对象，直接传入 props 即可断言输出。</li></ol></li></ul></div><p><a href="https://zh-hans.react.dev/learn/keeping-components-pure" target="_blank" rel="noopener noreferrer">React - 保持组件纯粹</a></p><h2 id="将-ui-视为树" tabindex="-1"><a class="header-anchor" href="#将-ui-视为树"><span>将 UI 视为树</span></a></h2><p>在 React 中，<strong>将 UI 视为一棵树</strong> 。</p><p>React 应用由<strong>组件</strong>构成，而组件之间通过<strong>嵌套</strong>形成<strong>树形结构</strong>。</p><h4 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例：</span></a></h4><div class="language-jsx line-numbers-mode" data-highlighter="shiki" data-ext="jsx" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-jsx"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">function</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> App</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">div</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Header</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Sidebar</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">        &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Content</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      &lt;/</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">      &lt;</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">Footer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">div</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  );</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这会形成如下组件树：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>App</span></span>
<span class="line"><span>├── div</span></span>
<span class="line"><span>│   ├── Header</span></span>
<span class="line"><span>│   ├── Main</span></span>
<span class="line"><span>│   │   ├── Sidebar</span></span>
<span class="line"><span>│   │   └── Content</span></span>
<span class="line"><span>│   └── Footer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>每个 React 组件都是树中的一个节点</strong>，父组件是子组件的“容器”，子组件是父组件的“叶子”或“子树”。</p><p>这种树形结构使得 UI 具备：</p><ul><li><strong>层次性</strong>：清晰的父子关系</li><li><strong>可组合性</strong>：小组件组合成复杂 UI</li><li><strong>局部更新能力</strong>：某一部分变化，只需更新子树</li></ul><h4 id="什么是渲染树" tabindex="-1"><a class="header-anchor" href="#什么是渲染树"><span>什么是渲染树？</span></a></h4><p>在 React 语境中，“渲染树”通常指：</p><blockquote><p><strong>由 React 元素（React Elements）组成的树形结构，它是组件执行后生成的、用于描述 UI 的中间表示。</strong></p></blockquote><p>它不是浏览器原生的“渲染树”（CSSOM + DOM 合成的用于绘制的树），而是 React 内部用于<strong>协调和更新</strong>的数据结构。</p><p><a href="https://zh-hans.react.dev/learn/understanding-your-ui-as-a-tree" target="_blank" rel="noopener noreferrer">React - 将 UI 视为树</a></p><h2 id="渲染和提交" tabindex="-1"><a class="header-anchor" href="#渲染和提交"><span>渲染和提交</span></a></h2><p>在 React 中，渲染组件的过程可以分为三个核心步骤：</p><ol><li><p><strong>触发更新</strong><br> 当组件的 <code>state</code> 或 <code>props</code> 发生变化时，React 会启动重新渲染流程。</p></li><li><p><strong>渲染阶段（Render Phase）</strong><br> React 调用组件函数，根据当前的 <code>props</code> 和 <code>state</code> 生成一棵新的 <strong>React 元素树</strong>（也称为虚拟 DOM 树或渲染树）。同时，React 将新树与旧树进行对比（协调，Reconciliation），确定需要更新的部分。<br> 此阶段必须是<strong>纯的</strong>——不能包含副作用（如修改 DOM、发送请求等），且可能被 React 中断或重复执行。</p></li><li><p><strong>提交阶段（Commit Phase）</strong><br> 一旦计算完成，React 会<strong>同步地</strong>将变更应用到真实 DOM，并执行副作用逻辑（如 <code>useEffect</code> 或类组件的 <code>componentDidMount/Update</code>）。<br> 此阶段不可中断，是执行 DOM 操作和副作用的安全时机。</p></li></ol><p><a href="https://zh-hans.react.dev/learn/render-and-commit" target="_blank" rel="noopener noreferrer">渲染和提交</a></p>`,30)])])}const r=i(t,[["render",l]]),d=JSON.parse('{"path":"/web/react/Understand/","title":"Understand","lang":"zh-CN","frontmatter":{"title":"Understand","createTime":"2025/10/20 11:33:08","permalink":"/web/react/Understand/","description":"保持组件纯粹 部分 JavaScript 函数是 纯粹 的，这类函数通常被称为纯函数。纯函数仅执行计算操作，不做其他操作。你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。 在 React 中，保持组件纯粹 是一个核心理念，源自函数式编程思想。它强调 React 组件应当像纯函数一样工作。 而...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Understand\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-11-03T08:38:06.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://zhenghaoyang.cn/web/react/Understand/"}],["meta",{"property":"og:site_name","content":"Hoey"}],["meta",{"property":"og:title","content":"Understand"}],["meta",{"property":"og:description","content":"保持组件纯粹 部分 JavaScript 函数是 纯粹 的，这类函数通常被称为纯函数。纯函数仅执行计算操作，不做其他操作。你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。 在 React 中，保持组件纯粹 是一个核心理念，源自函数式编程思想。它强调 React 组件应当像纯函数一样工作。 而..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-03T08:38:06.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-03T08:38:06.000Z"}]]},"readingTime":{"minutes":3.76,"words":1129},"git":{"createdTime":1760931772000,"updatedTime":1762159086000,"contributors":[{"name":"zhenghaoyang24","username":"zhenghaoyang24","email":"zhenghaoyang24@foxmail.com","commits":5,"avatar":"https://avatars.githubusercontent.com/zhenghaoyang24?v=4","url":"https://github.com/zhenghaoyang24"}]},"autoDesc":true,"filePathRelative":"web/4.React/understand.md","headers":[]}');export{r as comp,d as data};
